package main

import (
	"fmt"
	"net/http"
	"strconv"
	"sync"

	"github.com/mattermost/mattermost-server/v5/model"
	"github.com/mattermost/mattermost-server/v5/plugin"

	"mumble.info/grumble/grumble"
	// "mumble.info/grumble/pkg/logtarget"
	// "mumble.info/grumble/pkg/web"
)

// Plugin implements the interface expected by the Mattermost server to communicate between the server and plugin processes.
type Plugin struct {
	plugin.MattermostPlugin

	// configurationLock synchronizes access to the configuration.
	configurationLock sync.RWMutex

	// configuration is the active plugin configuration. Consult getConfiguration and
	// setConfiguration for usage.
	configuration *configuration

	// the grumble server instance
	grumbleServer *grumble.Server

	// true if the server is using autogenerated certs, to avoid
	// generating new ones on a configuration change
	usingGeneratedCerts bool
}

// ServeHTTP demonstrates a plugin that handles HTTP requests by greeting the world.
func (p *Plugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	if !p.grumbleServer.IsRunning() {
		fmt.Fprintf(w, "Grumble server has not been started")
		return
	}

	p.grumbleServer.Webwsl().ServeHTTP(w, r)
}

func (p *Plugin) Certs() ([]byte, []byte, *model.AppError) {
	cert, err := p.API.KVGet("cert")
	if err != nil {
		return nil, nil, err
	}

	key, err := p.API.KVGet("key")
	if err != nil {
		return nil, nil, err
	}

	return cert, key, nil
}

func (p *Plugin) SetCerts(certBytes, keyBytes []byte) *model.AppError {
	if err := p.API.KVSet("cert", certBytes); err != nil {
		return err
	}
	if err := p.API.KVSet("key", keyBytes); err != nil {
		return err
	}
	return nil
}

func (p *Plugin) OnActivate() error {
	p.API.LogInfo("Activating plugin")

	var err error
	p.grumbleServer, err = grumble.NewServer(1) // ToDo: maybe load from kvstore if existing already?
	if err != nil {
		return fmt.Errorf("cannot create grumble server: %w", err)
	}
	p.grumbleServer.Set("NoWebServer", "false")

	if err := p.applyConfig(); err != nil {
		return fmt.Errorf("error applying plugin configuration: %w", err)
	}

	if err := p.API.RegisterCommand(createGrumbleCommand()); err != nil {
		return fmt.Errorf("error registering plugin command: %w", err)
	}

	return p.StartServer()
}

func (p *Plugin) OnDeactivate() error {
	p.API.LogInfo("Deactivating plugin")
	grumbleServer := p.grumbleServer
	p.grumbleServer = nil
	p.usingGeneratedCerts = false

	return grumbleServer.Stop()
}

func (p *Plugin) applyConfig() error {
	p.API.LogInfo("Applying configuration")

	p.grumbleServer.Set("Port", strconv.Itoa(p.configuration.Port))
	p.grumbleServer.Set("WebPort", strconv.Itoa(p.configuration.WebPort))

	var appErr *model.AppError
	var certBytes, keyBytes []byte
	certBytes, keyBytes, appErr = p.Certs()
	if appErr != nil {
		p.API.LogInfo("Certificates not found, generating")
		certBytes, keyBytes, err := grumble.GenerateSelfSignedCertBytes()
		if err != nil {
			return fmt.Errorf("cannot generate self signed certificates: %w", err)
		}

		if err := p.SetCerts(certBytes, keyBytes); err != nil {
			return fmt.Errorf("cannot save certs in the kvstore: %w", err)
		}
	}

	p.grumbleServer.Set("Cert", string(certBytes))
	p.grumbleServer.Set("Key", string(keyBytes))

	/*
	// ToDo: read certs
	if p.configuration.CertPath != "" && p.configuration.KeyPath != "" {
		p.usingGeneratedCerts = false

	} else if !p.usingGeneratedCerts {
		p.usingGeneratedCerts = true
		// ToDo: generate and use certs
	}
	*/
	return nil
}

func (p *Plugin) StartServer() error {
	p.API.LogInfo("Starting grumble server")
	if p.grumbleServer.IsRunning() {
		p.API.LogInfo("Server already running. Skipping start")
		return nil
	}

	return p.grumbleServer.StartWithConfig()
}

func (p *Plugin) StopServer() error {
	p.API.LogInfo("Stopping grumble server")
	if !p.grumbleServer.IsRunning() {
		p.API.LogInfo("Server already stopped. Skipping stop")
		return nil
	}

	return p.grumbleServer.Stop()
}
